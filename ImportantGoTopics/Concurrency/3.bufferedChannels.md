
## Buffered Channels

> * This type of channel allows you to store more than one piece of data specified by the capacity, when that capacity is reached, subsequent messages that are sent to the channel will block until at least one message is read so that the channel has capacity again.
> * To create a buffered channel we only need to pass an additional parameter to the make function: 
```go bufchan := make(chan int, 5)```
> * this channel will accept 5 integers , if 6th integer is sent then receive operation has to be made until then send will be blocked similary when receive operation is made when channel is completely emtpy then receive operation will be blocked until sent operation is performed
> * The data structure used to keep track of the capacity of the channel is a queue, which means that the first element that gets into the queue will be the first getting out of the queue.

### lets look at an example for a buffered channels
```go
package dummy

import (
	"fmt"
	"math/rand"
	"time"
)

func BufferedFunc() {
	bufferedChan := make(chan int, 5)
	go generateRandomNumber(bufferedChan)

	time.Sleep(time.Second * 5)
	for buf := range bufferedChan {
		fmt.Println(buf)
	}
}

func generateRandomNumber(bufferedChan chan<- int) {
	defer close(bufferedChan)
	for i := 0; i < 5; i++ {
		time.Sleep(1 * time.Second)
		randomNum := rand.Intn(10)
		bufferedChan <- randomNum
	}
}
```
