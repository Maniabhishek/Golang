## Unbuffered Channels

> This type of channel only allows to send one piece of data and blocks the current goroutine until another one performs a receive operation on the channel. The same thing will happen if a receive operation on a channel is performed before a send operation, the goroutine where the receive operation was made will be blocked until another goroutine sends a message through the same channel. lets see it with an example
>> summary(for above)
>> * allows to send one piece of data
>> * blocks the current go routine

``` go
package main

import (
	"fmt"
	"time"
)

var (
	defaultTags = []string{"SystemUser", "User", "NewUser", "System"}
)

type Tag struct {
	Name, Type string
}

type User struct {
	Id, Name, LastName, Status string
	Tags                       []*Tag
}

type Post struct {
	Title  string
	Status string
	UserId string
}

func main() {
	blocking()	
}
 
/*
Main goroutine will be blocked until second goroutine
sends a message letting the main goroutine know that has finished its work
and so the main go routine can continue
*/
func blocking() {
	user := &User{}
	done := make(chan bool) // unbuffered channel

	go func() {
		fmt.Println("[Second-GoRoutine] Start Building User")
		buildingUser(user)
		fmt.Println("[Second-GoRoutine] Finished Building User")
		done <- true

		fmt.Println("[Second-GoRoutine] Set default user tags")
		setDefaultTags(user)
	}()

	fmt.Println("[Main-Goroutine] Start importing Posts")
	posts := importingPosts()
	fmt.Println("[Main-Goroutine] Finish importing Posts")
	fmt.Println("[Main-Goroutine] -----waiting------")
	<-done

	mergeUserPosts(user, posts)
	fmt.Println("Done!!")
	fmt.Printf("User %v\n", user)
	for _, post := range posts {
		fmt.Printf("Post %v\n", post)
	}
}

func mergeUserPosts(user *User, posts []*Post) {
	fmt.Println("[Main-Goroutine] Start merging user posts")
	for _, post := range posts {
		post.UserId = user.Id
	}
	fmt.Println("[Main-Goroutine] Finished merging user posts")
}

func importingPosts() []*Post {
	time.Sleep(1 * time.Second)
	titles := []string{"Post 1", "Random Post", "Second Post"}
	posts := []*Post{}
	for _, title := range titles {
		posts = append(posts, &Post{Title: title, Status: "draft"})
	}

	return posts
}

func buildingUser(user *User) {
	time.Sleep(2 * time.Second)
	user.Name = "John"
	user.LastName = "Doe"
	user.Status = "active"
	user.Id = "1"
}

func setDefaultTags(user *User) {
	time.Sleep(1 * time.Second)
	for _, tagName := range defaultTags {
		user.Tags = append(user.Tags, &Tag{Name: tagName, Type: "System"})
	}
}
```
Output
> main goroutine start creating features
> created feature=> 0x1400011a020
> main go routine waits 
> create product go routine starts
> this is app &{ []}
> creating app in main go routine &{laptop this is laptop 190 false []} &{ []}
> {test app [0x1400012c000]}

Let's understand the output

> * Let’s understand the output. When the program starts, an empty user object is created and a channel of type boolean(unbuffered channel) in lines 36 and 37 respectively, then a goroutine is created in line 45 which means that the piece of code within that function will be running in a separate goroutine.
> * The execution of the main goroutine continues and in line 49 we have a print statement, then in the second goroutine, since it is running concurrently at this point, it reaches line 40 and also executes a print statement.
> * The main goroutine continues and calls the method importingPosts and makes also two more print statements, the last one being [Main-Goroutine] ——--waiting------ , this is where the blocking concept that we talked about earlier comes into play, in line 59 we see that the main goroutine is reading from the donechannel, this basically means that the main goroutine will not continue its execution until the second goroutine sends a message to this channel.
> * In the second goroutine, the buildUser function is called and it prints [Second-GoRoutine] Finished Building User , then in the next line, it sends a message to the channel. At this point, the main goroutine will detect this and it will continue its execution, as well as the second goroutine.
> * The methods mergeUserPosts and setDefaultTags are called in the main and second goroutine respectively and we get their corresponding logs.
> * When we get to lines 63 to 66, the user and its posts are printed out, but if you check the tags array in the user struct is empty. The reason is that after the second goroutine sent a message to the main goroutine, both goroutines continued executing concurrently and as I previously mention the main goroutine will not wait until other goroutines finished executing, that being said, the second goroutine did not complete its work appending the user tags into the struct before the main goroutine finished and that is why the array is empty. If we remove line 97, we’ll be able to see the tags array is now filled in.

### another example
```go
package dummy3

import (
	"fmt"
	"time"
)

type Features struct {
	specs []string
}

type Product struct {
	name    string
	summary string
	price   float64
	active  bool
	feature []*Features
}

type App struct {
	name    string
	product []*Product
}

/*
Main goroutine will be blocked until second goroutine
sends a message letting the main goroutine know that has finished its work
and so the main go routine can continue
*/
func Blocking() {
	done := make(chan bool)
	var product Product
	var features Features
	var app App

	// fmt.Println(roduct)

	go func() {
		fmt.Println("create product go routine starts")
		createProduct(&product)
		done <- true
		makeProductActive(&product)
		addProductFeature(&product, &features)
		fmt.Println(product.feature[0].specs)
		fmt.Println("creat product go routine end")
	}()
	fmt.Println("main goroutine start creating features")
	createFeature(&features)
	fmt.Println("main go routine waits ")
	<-done
	fmt.Println("this is app", &app)
	createApp(&product, &features, &app)
	fmt.Println(app)
}

func createProduct(product *Product) {
	time.Sleep(1 * time.Second)
	product.name = "laptop"
	product.summary = "this is laptop"
	product.price = 190
}

func createFeature(feature *Features) {
	feature.specs = []string{"8gb ram"}
	fmt.Println("created feature=>", &feature)
}

func createApp(product *Product, feature *Features, app *App) {
	fmt.Println("creating app in main go routine", product, app)
	app.name = "test app"
	app.product = []*Product{product}
}

func makeProductActive(product *Product) {
	time.Sleep(time.Second * 1)
	product.active = true
}

func addProductFeature(product *Product, feature *Features) {
	fmt.Println("adding product feature")
	product.feature = []*Features{feature}
	fmt.Println("in addProductFeature", product)
}

```

> * With this example, we learned how to create an unbuffered channel using the built-in make function.
>> ```go 
>>  done := make(chan int) 
>> ```
> Also how to send and receive data from a channel
>> ``` go
>>  done <- true // send
>>  <-done // receive ignorting value
>> resp := <-done // receive storing value in a variable
>> ```
> Also, we saw how goroutines block execution if no other goroutine has sent/receive a message through the channel.

### channels can also be used to as a way of communicating multiple goroutines by using the result of one goroutines as the parameters for the another one 
#### lets take a look at the another example using multiple goroutines
